{"version":3,"sources":["services/giphy.ts","features/gifs/gifsSlice.ts","utils/deduplicateById.ts","hooks/usePrevious.ts","components/VisibilityTrigger.tsx","features/gifs/GifGrid.tsx","hooks/useScrollPosition.ts","hooks/useMeasure.ts","features/gifs/GifSearch.tsx","hooks/useWindowSize.ts","features/gifs/GifLightbox.tsx","App.tsx","app/store.ts","serviceWorker.ts","theme/theme.ts","theme/colors.ts","index.tsx"],"names":["giphy","GiphyFetch","process","gifsSlice","createSlice","name","initialState","searchQuery","focusedGifId","gifs","loadingGifsPage","hasNextPage","networkError","reducers","updateSearchQuery","state","action","payload","focusGif","clearGifFocus","requestGifs","newSearch","receiveGifs","items","duplicatesById","forEach","item","id","reverse","reduce","newList","unshift","deduplicateById","concat","length","totalCount","gifsRequestFailure","error","reducer","actions","selectSearchQuery","selectGifs","selectLoadingGifsPage","selectHasNextPage","selectFocusedGif","find","gif","fetchNextPage","dispatch","getState","a","currentGifsOffset","search","offset","limit","result","trending","data","pagination","total_count","message","debounceTimeoutHandle","setSearchQuery","query","clearTimeout","setTimeout","usePrevious","value","ref","useRef","useEffect","current","VisibilityTrigger","onVisible","onHidden","rest","elementRef","React","isVisible","setIsVisible","wasVisible","observer","IntersectionObserver","entries","isIntersecting","observe","disconnect","useStyles","makeStyles","root","width","position","cell","left","opacity","top","animationName","animationDuration","animationTimingFunction","animationFillMode","from","to","GifGrid","gap","classes","useDispatch","onVisibilityTriggerVisible","onGifClick","ev","preventDefault","toString","useSelector","loading","columns","isSmall","useMediaQuery","theme","breakpoints","up","useColumns","scrollPosition","useState","setScrollPosition","debounced","debounce","window","scrollY","document","addEventListener","removeEventListener","useScrollPosition","height","bounds","set","ResizeObserver","entry","contentRect","ro","useMeasure","gridProps","columnWidth","heights","Array","fill","itemData","map","column","indexOf","Math","min","getGifHeight","transform","visible","className","style","max","i","key","Box","display","flexDirection","alignItems","CircularProgress","backgroundColor","palette","background","paper","color","text","primary","GifSearch","props","InputProps","onInputChange","event","target","onClear","TextField","label","onChange","variant","clsx","endAdornment","IconButton","onClick","Clear","useWindowSize","documentElement","clientWidth","clientHeight","windowSize","setWindowSize","GifLightbox","onClose","windowWidth","Dialog","open","maxWidth","marginBottom","spacing","zIndex","modal","App","Container","component","Typography","Link","href","fullWidth","store","configureStore","gifsReducer","middleware","thunk","Boolean","location","hostname","match","baseDarkPalette","type","main","secondary","default","createMuiTheme","darkPalette","darkTheme","shape","typography","fontSize","overrides","MuiAppBar","colorDefault","MuiTypography","h1","down","h2","h3","h4","MuiTextField","MuiButton","MuiLink","underline","ReactDOM","render","StrictMode","ThemeProvider","CssBaseline","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.4038eee8.chunk.js","sourcesContent":["import { GiphyFetch } from '@giphy/js-fetch-api';\n\nexport const giphy = new GiphyFetch(process.env.REACT_APP_GIPHY_KEY);\n","import {\n  createSlice,\n  PayloadAction,\n  ThunkAction,\n  Action,\n} from '@reduxjs/toolkit';\nimport { RootState } from '../../app/store';\nimport { IGif } from '@giphy/js-types';\nimport { giphy } from '../../services/giphy';\nimport { deduplicateById } from '../../utils/deduplicateById';\n\nconst GIF_PAGE_SIZE = 50;\n\ninterface GifsState {\n  searchQuery: string;\n  focusedGifId: string | null;\n  gifs: IGif[];\n  loadingGifsPage: boolean;\n  hasNextPage: boolean;\n  networkError: string | null;\n}\n\nconst initialState: GifsState = {\n  searchQuery: '',\n  focusedGifId: null,\n  gifs: [],\n  loadingGifsPage: false,\n  hasNextPage: true,\n  networkError: null,\n};\n\nexport const gifsSlice = createSlice({\n  name: 'gifs',\n  initialState,\n  reducers: {\n    /**\n     * @note in case you're not familiar with redux toolkit, the reducers below\n     * are using Immer to mimic a mutable interface for the store - I'm *not* directly\n     * mutating the store in a reducer!\n     */\n    updateSearchQuery: (state, action: PayloadAction<string>) => {\n      state.searchQuery = action.payload;\n    },\n    focusGif: (state, action: PayloadAction<string>) => {\n      state.focusedGifId = action.payload;\n    },\n    clearGifFocus: (state) => {\n      state.focusedGifId = null;\n    },\n    requestGifs: (state, action: PayloadAction<{ newSearch: boolean }>) => {\n      state.loadingGifsPage = true;\n      // every new fetch might have a next page\n      state.hasNextPage = true;\n      if (action.payload.newSearch) {\n        // this request resets the cache.\n        state.gifs = [];\n      }\n    },\n    receiveGifs: (\n      state,\n      action: PayloadAction<{ gifs: IGif[]; totalCount: number }>,\n    ) => {\n      state.gifs = deduplicateById(state.gifs.concat(action.payload.gifs));\n      state.hasNextPage = state.gifs.length <= action.payload.totalCount;\n      state.loadingGifsPage = false;\n    },\n    /** @note I didn't end up using the error (or ever encountering one), but it's here for reference */\n    gifsRequestFailure: (state, action: PayloadAction<{ error: string }>) => {\n      state.networkError = action.payload.error;\n      state.loadingGifsPage = false;\n      // don't retry loading the page if we encountered an error.\n      state.hasNextPage = false;\n    },\n  },\n});\n\nexport const { reducer } = gifsSlice;\n\nexport const {\n  focusGif,\n  clearGifFocus,\n  requestGifs,\n  receiveGifs,\n  gifsRequestFailure,\n  updateSearchQuery,\n} = gifsSlice.actions;\n\nexport const selectSearchQuery = (state: RootState) => state.gifs.searchQuery;\nexport const selectFocusedGifId = (state: RootState) => state.gifs.focusedGifId;\nexport const selectGifs = (state: RootState) => state.gifs.gifs;\nexport const selectLoadingGifsPage = (state: RootState) =>\n  state.gifs.loadingGifsPage;\nexport const selectNetworkError = (state: RootState) => state.gifs.networkError;\nexport const selectHasNextPage = (state: RootState) => state.gifs.hasNextPage;\nexport const selectFocusedGif = (state: RootState) =>\n  state.gifs.gifs.find((gif) => gif.id === state.gifs.focusedGifId);\n\n// Async actions\n\n/**\n * Fetches the next page of GIFs according to the\n * current search query (if any). If no query is provided,\n * it fetches trending GIFs.\n */\nexport function fetchNextPage({\n  newSearch,\n}: {\n  newSearch: boolean;\n}): ThunkAction<Promise<void>, RootState, undefined, Action> {\n  return async function (dispatch, getState) {\n    dispatch(gifsSlice.actions.requestGifs({ newSearch }));\n\n    const searchQuery = selectSearchQuery(getState());\n    const currentGifsOffset = selectGifs(getState()).length;\n\n    try {\n      let result;\n\n      // based on the query, choose which type of fetch to do\n      if (searchQuery) {\n        result = await giphy.search(searchQuery, {\n          offset: currentGifsOffset,\n          limit: GIF_PAGE_SIZE,\n        });\n      } else {\n        result = await giphy.trending({\n          offset: currentGifsOffset,\n          limit: GIF_PAGE_SIZE,\n        });\n      }\n      dispatch(\n        gifsSlice.actions.receiveGifs({\n          gifs: result.data,\n          totalCount: result.pagination.total_count,\n        }),\n      );\n    } catch (err) {\n      dispatch(gifsSlice.actions.gifsRequestFailure({ error: err.message }));\n    }\n  };\n}\n\n/**\n * the action which changes the search query also fires a debounced\n * function to queue up a refetch of the GIFs with the new search term.\n */\nlet debounceTimeoutHandle: NodeJS.Timeout | null = null;\nexport function setSearchQuery(\n  query: string,\n): ThunkAction<void, RootState, undefined, Action> {\n  return function (dispatch, getState) {\n    // first, update the store with the new search term\n    dispatch(gifsSlice.actions.updateSearchQuery(query));\n\n    // then, call a debounced function to fetch new GIFs based on the term\n\n    // if a previous fetch was queued up, cancel it\n    if (debounceTimeoutHandle) {\n      clearTimeout(debounceTimeoutHandle);\n    }\n\n    // queue a new fetch after 500ms of inactivity\n    debounceTimeoutHandle = setTimeout(async () => {\n      dispatch(fetchNextPage({ newSearch: true }));\n    }, 500);\n  };\n}\n","/**\n * A relatively efficient algorithm to deduplicate items in a list which share\n * an id.\n */\nexport function deduplicateById<T extends { id: string | number }>(items: T[]) {\n  // keep track of any duplicates with a map -\n  // each time we see an id, we increment the entry\n  const duplicatesById: Record<string | number, number> = {};\n  items.forEach((item) => {\n    duplicatesById[item.id] = (duplicatesById[item.id] ?? 0) + 1;\n  });\n\n  // then, we go through the list again, but in reverse. this time, each time\n  // we see an ID we decrement the entry. If it's 0, we add\n  // the item to the beginning of a new list.\n  return items.reverse().reduce<T[]>((newList, item) => {\n    duplicatesById[item.id] = duplicatesById[item.id] - 1;\n    if (duplicatesById[item.id] > 0) {\n      return newList;\n    }\n    newList.unshift(item);\n    return newList;\n  }, []);\n}\n","import { useRef, useEffect } from 'react';\n\n/**\n * Hook that returns the previous value stored in it. This is useful for comparing\n * props from one render to the next (for example, when using `useEffect` to handle\n * lifecycle changes).\n */\nconst usePrevious = <T>(value: T) => {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n};\n\nexport default usePrevious;\n","import * as React from 'react';\nimport usePrevious from '../hooks/usePrevious';\nimport IntersectionObserver from 'inteobs';\n\nexport type VisibilityTriggerProps = {\n  children?: React.ReactNode;\n  onVisible?: () => any;\n  onHidden?: () => any;\n};\n\nexport function VisibilityTrigger({\n  onVisible,\n  onHidden,\n  ...rest\n}: VisibilityTriggerProps) {\n  const elementRef = React.useRef<HTMLDivElement>(null);\n  const [isVisible, setIsVisible] = React.useState(false);\n  const wasVisible = usePrevious(isVisible);\n\n  React.useEffect(() => {\n    if (!!wasVisible !== isVisible) {\n      if (isVisible) {\n        onVisible?.();\n      } else {\n        onHidden?.();\n      }\n    }\n  }, [wasVisible, isVisible, onHidden, onVisible]);\n\n  React.useEffect(() => {\n    if (!elementRef.current) return;\n\n    const { current } = elementRef;\n\n    const observer = new IntersectionObserver((entries) => {\n      setIsVisible(entries[0].isIntersecting);\n    });\n\n    observer.observe(current);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [elementRef]);\n\n  return <div ref={elementRef} {...rest} />;\n}\n","import * as React from 'react';\nimport { Gif } from '@giphy/react-components';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  focusGif,\n  selectGifs,\n  fetchNextPage,\n  selectLoadingGifsPage,\n  selectHasNextPage,\n} from './gifsSlice';\nimport { getGifHeight } from '@giphy/js-util';\nimport { GifResult } from '@giphy/js-fetch-api';\nimport {\n  useMediaQuery,\n  Theme,\n  CircularProgress,\n  makeStyles,\n  Box,\n} from '@material-ui/core';\nimport { useMeasure } from '../../hooks/useMeasure';\nimport { VisibilityTrigger } from '../../components/VisibilityTrigger';\nimport { useScrollPosition } from '../../hooks/useScrollPosition';\n\n// a pixel buffer for the virtualization - we'll keep rendering items\n// even if they're this many pixels past the visible viewport.\n// This value is a tradeoff - too large and the performance suffers,\n// too small and scrolling upward looks like something broke. But\n// since users generally don't scroll upward as often as downward,\n// we can keep it a little tight - about 1 average screen height.\nconst VIRTUALIZATION_BUFFER = 1600;\n\nfunction useColumns() {\n  const isSmall = useMediaQuery<Theme>((theme) => theme.breakpoints.up('sm'));\n  const isLarge = useMediaQuery<Theme>((theme) => theme.breakpoints.up('md'));\n\n  if (isLarge) return 4;\n  else if (isSmall) return 2;\n  return 1;\n}\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    width: '100%',\n    position: 'relative',\n  },\n  cell: {\n    position: 'absolute',\n    left: 0,\n    opacity: 0,\n    top: 32,\n    animationName: '$fadeUp',\n    animationDuration: '800ms',\n    animationTimingFunction: 'ease-out',\n    animationFillMode: 'forwards',\n  },\n  '@keyframes fadeUp': {\n    from: { opacity: 0, top: 32 },\n    to: { opacity: 1, top: 0 },\n  },\n}));\n\n/**\n * This is a custom masonry grid designed to render the fetched\n * Giphy GIFs. It's responsive, loads infinitely, and virtualizes\n * the items as they move offscreen to keep performance smooth.\n */\nexport function GifGrid({ gap = 8 }: { gap?: number }) {\n  const classes = useStyles();\n\n  const dispatch = useDispatch();\n\n  // called when the infinite scroll trigger enters the viewport.\n  // fetches the next page of GIFs. The fact that this gets\n  // called on initial page load (since the trigger mounts and\n  // immediately fires) provides our initial gif load naturally.\n  const onVisibilityTriggerVisible = React.useCallback(() => {\n    dispatch(fetchNextPage({ newSearch: false }));\n  }, [dispatch]);\n\n  // attached to each Giphy Gif component. Opens the lightbox.\n  const onGifClick = React.useCallback(\n    (gif: GifResult['data'], ev: React.SyntheticEvent) => {\n      // preventing default is necessary since Giphy makes its Gif components\n      // links by default with no way to override that behavior otherwise.\n      ev.preventDefault();\n      dispatch(focusGif(gif.id.toString()));\n    },\n    [dispatch],\n  );\n\n  // selecting various state pieces we need to render the grid\n  const gifs = useSelector(selectGifs);\n  const loading = useSelector(selectLoadingGifsPage);\n  const hasNextPage = useSelector(selectHasNextPage);\n\n  /** @note custom masonry grid code below */\n\n  // column count is computed responsively\n  const columns = useColumns();\n\n  const scrollPosition = useScrollPosition();\n\n  // measuring the container element's width determines the width of each column,\n  // which we need to define before we can compute the heights of the elements\n  const [gridProps, { width }] = useMeasure<HTMLDivElement>();\n  // column width is determined by container width, accommodating the gaps between elements\n  const columnWidth = width / columns - gap * (columns - 1);\n  // to do a decent masonry layout you have to do a bit of computation within the render cycle.\n  // possibly, this could be cached or otherwise done out-of-band, but that's an optimization.\n  // To start, we create an array of column heights we will track\n  const heights = new Array(columns).fill(0);\n  // then, computing CSS transform values for each GIF item\n  const itemData = gifs.map((gif) => {\n    // selects the shortest column to place this item in\n    const column = heights.indexOf(Math.min(...heights));\n\n    // measure the GIF\n    const height = getGifHeight(gif, columnWidth);\n\n    // compute the pixel transform\n    const transform = `translate3d(${(width / columns + gap) * column}px, ${\n      heights[column]\n    }px, 0)`;\n\n    // update the column height, including gap\n    heights[column] = heights[column] + height + gap;\n\n    return {\n      transform,\n      /**\n       * @note for performance reasons, on any infinite list you want\n       * to virtualize. The cool thing about an absolute-positioned\n       * masonry grid like this is virtualization is dead simple - you\n       * simply stop rendering the items you can't see anymore. There's\n       * no need to worry about that affecting the positions of the ones you can.\n       */\n      visible:\n        heights[column] + height >= scrollPosition - VIRTUALIZATION_BUFFER,\n    };\n  });\n\n  return (\n    <>\n      <div\n        {...gridProps}\n        className={classes.root}\n        style={{ height: Math.max(...heights) }}\n      >\n        {width &&\n          gifs.map((gif, i) => {\n            const { transform, visible } = itemData[i];\n\n            // this is the virtualization - just don't render it!\n            if (!visible) return null;\n\n            return (\n              <Gif\n                key={gif.id}\n                gif={gif}\n                width={columnWidth || 100}\n                className={classes.cell}\n                style={{\n                  // assigning the correct CSS transform for this item\n                  transform,\n                }}\n                onGifClick={onGifClick}\n              />\n            );\n          })}\n      </div>\n      {hasNextPage && (\n        <Box\n          // a nice wide space so the user's scroll feels uninterrupted\n          height=\"75vh\"\n          display=\"flex\"\n          flexDirection=\"column\"\n          alignItems=\"center\"\n          width=\"100%\"\n        >\n          <VisibilityTrigger onVisible={onVisibilityTriggerVisible} />\n          {loading && <CircularProgress />}\n        </Box>\n      )}\n    </>\n  );\n}\n","import { useState, useEffect } from 'react';\nimport { debounce } from '@material-ui/core';\n\nexport function useScrollPosition() {\n  const [scrollPosition, setScrollPosition] = useState(0);\n\n  useEffect(() => {\n    function update() {\n      setScrollPosition(window.scrollY);\n    }\n    const debounced = debounce(update, 300);\n    document.addEventListener('scroll', debounced);\n\n    return () => {\n      document.removeEventListener('scroll', debounced);\n    };\n  }, []);\n\n  return scrollPosition;\n}\n","import { useRef, useState, useEffect } from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nexport function useMeasure<T extends HTMLElement = HTMLElement>() {\n  const ref = useRef<T>(null);\n\n  const [bounds, set] = useState({ left: 0, top: 0, width: 0, height: 0 });\n\n  const [ro] = useState(\n    () => new ResizeObserver(([entry]) => set(entry.contentRect)),\n  );\n\n  useEffect(() => {\n    if (ref.current) {\n      ro.observe(ref.current);\n      return () => ro.disconnect();\n    }\n  }, [ro]);\n\n  return [{ ref }, bounds] as const;\n}\n","import * as React from 'react';\nimport {\n  makeStyles,\n  Theme,\n  TextField,\n  OutlinedTextFieldProps,\n  IconButton,\n} from '@material-ui/core';\nimport { Clear } from '@material-ui/icons';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { selectSearchQuery, setSearchQuery } from './gifsSlice';\nimport clsx from 'clsx';\n\nexport type GifSearchProps = Omit<\n  OutlinedTextFieldProps,\n  'value' | 'onChange' | 'variant'\n>;\n\nconst useStyles = makeStyles<Theme, GifSearchProps>((theme) => ({\n  root: {\n    backgroundColor: theme.palette.background.paper,\n    color: theme.palette.text.primary,\n  },\n}));\n\nexport function GifSearch(props: GifSearchProps) {\n  const classes = useStyles(props);\n  const { className, InputProps, ...rest } = props;\n\n  const searchQuery = useSelector(selectSearchQuery);\n  const dispatch = useDispatch();\n  const onInputChange = React.useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      dispatch(setSearchQuery(event.target.value));\n    },\n    [dispatch],\n  );\n  const onClear = React.useCallback(() => {\n    dispatch(setSearchQuery(''));\n  }, [dispatch]);\n\n  return (\n    <TextField\n      label=\"Search!\"\n      value={searchQuery}\n      onChange={onInputChange}\n      variant=\"outlined\"\n      className={clsx(classes.root, className)}\n      InputProps={{\n        ...InputProps,\n        endAdornment: searchQuery && (\n          <IconButton onClick={onClear}>\n            <Clear />\n          </IconButton>\n        ),\n      }}\n      {...rest}\n    />\n  );\n}\n","import { useState, useEffect } from 'react';\nimport { debounce } from '@material-ui/core';\n\nfunction getInitialWidth() {\n  if (typeof window === 'undefined') return { width: 0, height: 0 };\n  return {\n    width: document.documentElement.clientWidth,\n    height: document.documentElement.clientHeight,\n  };\n}\n\nexport function useWindowSize() {\n  const [windowSize, setWindowSize] = useState(getInitialWidth());\n\n  useEffect(() => {\n    function update() {\n      setWindowSize({\n        width: document.documentElement.clientWidth,\n        height: document.documentElement.clientHeight,\n      });\n    }\n    const debounced = debounce(update, 100);\n    window.addEventListener('resize', debounced);\n\n    return () => {\n      window.removeEventListener('resize', debounced);\n    };\n  }, []);\n\n  return windowSize;\n}\n","import * as React from 'react';\nimport { Dialog } from '@material-ui/core';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { clearGifFocus, selectFocusedGif } from './gifsSlice';\nimport { Gif } from '@giphy/react-components';\nimport { useWindowSize } from '../../hooks/useWindowSize';\n\nexport function GifLightbox() {\n  const gif = useSelector(selectFocusedGif);\n\n  const dispatch = useDispatch();\n  const onClose = React.useCallback(() => {\n    dispatch(clearGifFocus());\n  }, [dispatch]);\n\n  // we want the lightbox to take up a good portion of the screen on\n  // every screen size, so we'll need this\n  const { width: windowWidth } = useWindowSize();\n\n  return (\n    <Dialog open={!!gif} onClose={onClose} maxWidth={false}>\n      {!!gif && <Gif gif={gif} width={windowWidth * 0.75} />}\n    </Dialog>\n  );\n}\n","import React from 'react';\r\nimport { GifGrid } from './features/gifs/GifGrid';\r\nimport {\r\n  Container,\r\n  makeStyles,\r\n  Box,\r\n  Typography,\r\n  Link,\r\n} from '@material-ui/core';\r\nimport { GifSearch } from './features/gifs/GifSearch';\r\nimport { GifLightbox } from './features/gifs/GifLightbox';\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {},\r\n  search: {\r\n    marginBottom: theme.spacing(2),\r\n    position: 'sticky',\r\n    top: theme.spacing(2),\r\n    zIndex: theme.zIndex.modal,\r\n  },\r\n}));\r\n\r\nfunction App() {\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <Box display=\"flex\" flexDirection=\"column\" alignItems=\"center\" width=\"100%\">\r\n      <Container component=\"header\" maxWidth=\"md\" style={{ marginBottom: 16 }}>\r\n        <Typography variant=\"h1\">Gifs!</Typography>\r\n        <Link href=\"https://github.com/a-type/signal-giphy#devlog\">\r\n          Read the devlog for more detail!\r\n        </Link>\r\n      </Container>\r\n      <Container component=\"section\" maxWidth=\"md\">\r\n        <GifSearch className={classes.search} fullWidth />\r\n        <GifGrid />\r\n        <GifLightbox />\r\n      </Container>\r\n    </Box>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\r\nimport { reducer as gifsReducer } from '../features/gifs/gifsSlice';\r\nimport thunk from 'redux-thunk';\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    gifs: gifsReducer,\r\n  },\r\n  middleware: [thunk],\r\n});\r\n\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import { createMuiTheme } from '@material-ui/core';\nimport { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\nimport colors from './colors';\n\nconst baseDarkPalette: ThemeOptions['palette'] = {\n  type: 'dark',\n  text: {\n    primary: colors.white,\n  },\n  primary: {\n    main: colors.bright,\n  },\n  secondary: {\n    main: colors.dark,\n  },\n  background: {\n    default: colors.black,\n    paper: colors.trueBlack,\n  },\n};\n\nconst { palette: darkPalette, breakpoints } = createMuiTheme({\n  palette: baseDarkPalette,\n});\n\nconst themeFactory = (palette: ThemeOptions['palette']) =>\n  createMuiTheme({\n    palette,\n    shape: {},\n    typography: {\n      fontSize: 16,\n    },\n    overrides: {\n      MuiAppBar: {\n        colorDefault: {\n          backgroundColor: 'transparent',\n        },\n      },\n      MuiTypography: {\n        /**\n         * @note I like to tweak the heading sizes in MUI for\n         * smaller screens, since they're very large by default.\n         */\n        h1: {\n          [breakpoints.down('sm')]: {\n            fontSize: '5vmax',\n          },\n        },\n        h2: {\n          [breakpoints.down('sm')]: {\n            fontSize: '4vmax',\n          },\n        },\n        h3: {\n          [breakpoints.down('sm')]: {\n            fontSize: '3.75vmax',\n          },\n        },\n        h4: {\n          [breakpoints.down('sm')]: {\n            fontSize: '3.3vmax',\n          },\n        },\n      },\n    },\n    props: {\n      MuiTextField: {\n        variant: 'filled',\n      },\n      MuiButton: {\n        color: 'primary',\n      },\n      MuiLink: {\n        underline: 'always',\n      },\n    },\n  });\n\nexport const darkTheme = themeFactory(darkPalette);\n","export default {\n  white: '#fff',\n  black: '#222831',\n  blackRgb: [42, 36, 56],\n  bright: '#eeeeee',\n  dark: '#a0a0af',\n  medium: '#e0e0eb',\n  mediumRgb: [53, 47, 68],\n  trueBlack: '#111321',\n  trueBlackRgb: [4, 4, 8],\n};\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { store } from './app/store';\r\nimport { Provider } from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport { ThemeProvider, CssBaseline } from '@material-ui/core';\r\nimport { darkTheme } from './theme/theme';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <ThemeProvider theme={darkTheme}>\r\n        <CssBaseline />\r\n        <App />\r\n      </ThemeProvider>\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root'),\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}